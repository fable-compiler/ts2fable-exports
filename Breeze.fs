// ts2fable 0.0.0
module rec Breeze

#nowarn "3390" // disable warnings for invalid XML comments

open System
open Fable.Core
open Fable.Core.JS

type Error = System.Exception
type Function = System.Action
type RegExp = System.Text.RegularExpressions.Regex

let [<Import("core","breeze-client")>] core: Core.IExports = jsNative
let [<Import("config","breeze-client")>] config: Config.IExports = jsNative
let [<Import("DataType","breeze-client")>] DataType: DataType = jsNative
let [<Import("EntityAction","breeze-client")>] EntityAction: EntityAction = jsNative
let [<Import("EntityState","breeze-client")>] EntityState: EntityState = jsNative
let [<Import("FetchStrategy","breeze-client")>] FetchStrategy: FetchStrategy = jsNative
let [<Import("FilterQueryOp","breeze-client")>] FilterQueryOp: FilterQueryOp = jsNative
let [<Import("MergeStrategy","breeze-client")>] MergeStrategy: MergeStrategy = jsNative
let [<Import("metadataVersion","breeze-client")>] metadataVersion: string = jsNative
let [<Import("remoteAccess_odata","breeze-client")>] remoteAccess_odata: string = jsNative
let [<Import("remoteAccess_webApi","breeze-client")>] remoteAccess_webApi: string = jsNative
let [<Import("version","breeze-client")>] version: string = jsNative

type [<AllowNullLiteral>] IExports =
    abstract AutoGeneratedKeyType: AutoGeneratedKeyTypeStatic
    abstract ComplexAspect: ComplexAspectStatic
    abstract ComplexType: ComplexTypeStatic
    abstract DataProperty: DataPropertyStatic
    abstract DataService: DataServiceStatic
    abstract DataServiceAdapter: DataServiceAdapterStatic
    abstract DeletedEntityKey: DeletedEntityKeyStatic
    abstract JsonResultsAdapter: JsonResultsAdapterStatic
    abstract DataTypeSymbol: DataTypeSymbolStatic
    abstract EntityActionSymbol: EntityActionSymbolStatic
    abstract EntityAspect: EntityAspectStatic
    abstract PropertyChangedEventArgs: PropertyChangedEventArgsStatic
    abstract PropertyChangedEvent: PropertyChangedEventStatic
    abstract ValidationErrorsChangedEventArgs: ValidationErrorsChangedEventArgsStatic
    abstract ValidationErrorsChangedEvent: ValidationErrorsChangedEventStatic
    abstract EntityKey: EntityKeyStatic
    abstract EntityManager: EntityManagerStatic
    abstract EntityChangedEventArgs: EntityChangedEventArgsStatic
    abstract EntityChangedEvent: EntityChangedEventStatic
    abstract HasChangesChangedEventArgs: HasChangesChangedEventArgsStatic
    abstract HasChangesChangedEvent: HasChangesChangedEventStatic
    abstract EntityQuery: EntityQueryStatic
    abstract EntityStateSymbol: EntityStateSymbolStatic
    abstract EntityType: EntityTypeStatic
    abstract FetchStrategySymbol: FetchStrategySymbolStatic
    abstract FilterQueryOpSymbol: FilterQueryOpSymbolStatic
    abstract LocalQueryComparisonOptions: LocalQueryComparisonOptionsStatic
    abstract MergeStrategySymbol: MergeStrategySymbolStatic
    abstract MetadataStore: MetadataStoreStatic
    abstract NamingConvention: NamingConventionStatic
    abstract NavigationProperty: NavigationPropertyStatic
    abstract Predicate: PredicateStatic
    abstract QueryOptions: QueryOptionsStatic
    abstract SaveOptions: SaveOptionsStatic
    abstract ValidationError: ValidationErrorStatic
    abstract ValidationOptions: ValidationOptionsStatic
    abstract Validator: ValidatorStatic

module Core =

    type [<AllowNullLiteral>] IExports =
        abstract Enum: EnumStatic
        abstract EnumSymbol: EnumSymbolStatic
        abstract Event: EventStatic
        abstract objectForEach: obj: Object * kvfn: (string -> obj option -> unit) -> unit
        abstract extend: target: Object * source: Object -> Object
        abstract propEq: propertyName: string * value: obj option -> (Object -> bool)
        abstract pluck: propertyName: string -> (Object -> obj option)
        abstract arrayEquals: a1: ResizeArray<obj option> * a2: ResizeArray<obj option> * equalsFn: (obj option -> obj option -> bool) -> bool
        abstract arrayFirst: a1: ResizeArray<obj option> * predicate: (obj option -> bool) -> obj option
        abstract arrayIndexOf: a1: ResizeArray<obj option> * predicate: (obj option -> bool) -> float
        abstract arrayRemoveItem: array: ResizeArray<obj option> * item: obj option * shouldRemoveMultiple: bool -> obj option
        abstract arrayRemoveItem: array: ResizeArray<obj option> * predicate: (obj option -> bool) * shouldRemoveMultiple: bool -> obj option
        abstract arrayZip: a1: ResizeArray<obj option> * a2: ResizeArray<obj option> * callback: (obj option -> obj option -> obj option) -> ResizeArray<obj option>
        abstract requireLib: libnames: string * errMessage: string -> Object
        abstract using: obj: Object * property: string * tempValue: obj option * fn: (unit -> obj option) -> obj option
        abstract memoize: fn: (ResizeArray<obj option> -> obj option) -> obj option
        abstract getUuid: unit -> string
        abstract durationToSeconds: duration: string -> float
        abstract isDate: o: obj option -> bool
        abstract isGuid: o: obj option -> bool
        abstract isDuration: o: obj option -> bool
        abstract isFunction: o: obj option -> bool
        abstract isEmpty: o: obj option -> bool
        abstract isNumeric: o: obj option -> bool
        abstract stringStartsWith: str: string * prefix: string -> bool
        abstract stringEndsWith: str: string * suffix: string -> bool
        abstract formatString: format: string * [<ParamArray>] args: obj option[] -> string
        /// Change text to title case with spaces, e.g. 'myPropertyName12' to 'My Property Name 12'
        abstract titleCase: str: string -> string
        /// Return the ES5 property descriptor for the property, which may be on a prototype of the object
        abstract getPropertyDescriptor: obj: obj option * propertyName: string -> PropertyDescriptor
        /// safely perform toJSON logic on objects with cycles.  Replacer function can map or exclude properties.
        abstract toJSONSafe: obj: obj option * ?replacer: (string -> obj option -> obj option) -> obj option
        /// Default value replacer for toJSONSafe.  Replaces entityAspect and other internal properties with undefined.
        abstract toJSONSafeReplacer: prop: string * ``val``: obj option -> obj option

    type [<AllowNullLiteral>] ErrorCallback =
        [<Emit("$0($1...)")>] abstract Invoke: error: Error -> unit

    type [<AllowNullLiteral>] IEnum =
        abstract contains: object: obj option -> bool
        abstract fromName: name: string -> EnumSymbol
        abstract getNames: unit -> ResizeArray<string>
        abstract getSymbols: unit -> ResizeArray<EnumSymbol>

    type [<AllowNullLiteral>] Enum =
        inherit IEnum
        abstract addSymbol: ?propertiesObj: obj -> EnumSymbol
        abstract contains: object: obj option -> bool
        abstract fromName: name: string -> EnumSymbol
        abstract getNames: unit -> ResizeArray<string>
        abstract getSymbols: unit -> ResizeArray<EnumSymbol>
        abstract resolveSymbols: unit -> unit

    type [<AllowNullLiteral>] EnumStatic =
        [<EmitConstructor>] abstract Create: name: string * ?methodObj: obj -> Enum
        abstract isSymbol: object: obj option -> bool

    type [<AllowNullLiteral>] EnumSymbol =
        abstract parentEnum: IEnum with get, set
        abstract getName: unit -> string
        abstract toString: unit -> string

    type [<AllowNullLiteral>] EnumSymbolStatic =
        [<EmitConstructor>] abstract Create: unit -> EnumSymbol

    type [<AllowNullLiteral>] Event =
        abstract publish: data: obj option * ?publishAsync: bool * ?errorCallback: ErrorCallback -> unit
        abstract publishAsync: data: obj option * ?errorCallback: ErrorCallback -> unit
        abstract subscribe: ?callback: (obj option -> unit) -> float
        abstract unsubscribe: unsubKey: float -> bool
        abstract clear: unit -> unit

    type [<AllowNullLiteral>] EventStatic =
        [<EmitConstructor>] abstract Create: name: string * publisher: obj option * ?defaultErrorCallback: ErrorCallback -> Event
        abstract enable: eventName: string * target: obj option -> unit
        abstract enable: eventName: string * target: obj option * isEnabled: bool -> unit
        abstract enable: eventName: string * target: obj option * isEnabled: Function -> unit
        abstract isEnabled: eventName: string * target: obj option -> bool

type [<AllowNullLiteral>] Entity =
    abstract entityAspect: EntityAspect with get, set
    abstract entityType: EntityType with get, set

type [<AllowNullLiteral>] ComplexObject =
    abstract complexAspect: ComplexAspect with get, set
    abstract complexType: ComplexType with get, set

type [<AllowNullLiteral>] IProperty =
    abstract name: string with get, set
    abstract nameOnServer: string with get, set
    abstract displayName: string with get, set
    abstract parentType: U2<EntityType, ComplexType> with get, set
    abstract validators: ResizeArray<Validator> with get, set
    abstract isDataProperty: bool with get, set
    abstract isNavigationProperty: bool with get, set
    abstract custom: obj option with get, set

type [<AllowNullLiteral>] IStructuralType =
    abstract complexProperties: ResizeArray<DataProperty> with get, set
    abstract dataProperties: ResizeArray<DataProperty> with get, set
    abstract name: string with get, set
    abstract ``namespace``: string with get, set
    abstract shortName: string with get, set
    abstract unmappedProperties: ResizeArray<DataProperty> with get, set
    abstract validators: ResizeArray<Validator> with get, set
    abstract custom: obj option with get, set

type [<AllowNullLiteral>] AutoGeneratedKeyType =
    interface end

type [<AllowNullLiteral>] AutoGeneratedKeyTypeStatic =
    [<EmitConstructor>] abstract Create: unit -> AutoGeneratedKeyType
    abstract Identity: AutoGeneratedKeyType with get, set
    abstract KeyGenerator: AutoGeneratedKeyType with get, set
    abstract None: AutoGeneratedKeyType with get, set

type [<AllowNullLiteral>] ComplexAspect =
    abstract complexObject: ComplexObject with get, set
    abstract getEntityAspect: unit -> EntityAspect
    abstract parent: Object with get, set
    abstract parentProperty: DataProperty with get, set
    abstract getPropertyPath: propName: string -> string
    abstract originalValues: Object with get, set

type [<AllowNullLiteral>] ComplexAspectStatic =
    [<EmitConstructor>] abstract Create: unit -> ComplexAspect

type [<AllowNullLiteral>] ComplexType =
    inherit IStructuralType
    abstract complexProperties: ResizeArray<DataProperty> with get, set
    abstract dataProperties: ResizeArray<DataProperty> with get, set
    abstract name: string with get, set
    abstract ``namespace``: string with get, set
    abstract shortName: string with get, set
    abstract unmappedProperties: ResizeArray<DataProperty> with get, set
    abstract validators: ResizeArray<Validator> with get, set
    abstract custom: obj option with get, set
    abstract addProperty: dataProperty: DataProperty -> ComplexType
    abstract getProperties: unit -> ResizeArray<DataProperty>

type [<AllowNullLiteral>] ComplexTypeStatic =
    [<EmitConstructor>] abstract Create: config: ComplexTypeOptions -> ComplexType

type [<AllowNullLiteral>] ComplexTypeOptions =
    abstract shortName: string option with get, set
    abstract ``namespace``: string option with get, set
    abstract dataProperties: ResizeArray<DataProperty> option with get, set
    abstract custom: Object option with get, set

type [<AllowNullLiteral>] DataProperty =
    inherit IProperty
    abstract complexTypeName: string with get, set
    abstract concurrencyMode: string with get, set
    abstract dataType: DataTypeSymbol with get, set
    abstract defaultValue: obj option with get, set
    abstract isComplexProperty: bool with get, set
    abstract isDataProperty: bool with get, set
    abstract isInherited: bool with get, set
    abstract isNavigationProperty: bool with get, set
    abstract isNullable: bool with get, set
    abstract isPartOfKey: bool with get, set
    abstract isUnmapped: bool with get, set
    abstract isSettable: bool with get, set
    abstract custom: obj option with get, set
    abstract maxLength: float with get, set
    abstract name: string with get, set
    abstract nameOnServer: string with get, set
    abstract displayName: string with get, set
    abstract parentType: U2<EntityType, ComplexType> with get, set
    abstract relatedNavigationProperty: NavigationProperty with get, set
    abstract validators: ResizeArray<Validator> with get, set

type [<AllowNullLiteral>] DataPropertyStatic =
    [<EmitConstructor>] abstract Create: config: DataPropertyOptions -> DataProperty

type [<AllowNullLiteral>] DataPropertyOptions =
    abstract complexTypeName: string option with get, set
    abstract concurrencyMode: string option with get, set
    abstract custom: obj option with get, set
    abstract dataType: DataTypeSymbol option with get, set
    abstract defaultValue: obj option with get, set
    abstract displayName: string option with get, set
    abstract isNullable: bool option with get, set
    abstract isPartOfKey: bool option with get, set
    abstract isScalar: bool option with get, set
    abstract isUnmapped: bool option with get, set
    abstract maxLength: float option with get, set
    abstract name: string option with get, set
    abstract nameOnServer: string option with get, set
    abstract validators: ResizeArray<Validator> option with get, set

type [<AllowNullLiteral>] DataService =
    abstract adapterInstance: DataServiceAdapter with get, set
    abstract adapterName: string with get, set
    abstract hasServerMetadata: bool with get, set
    abstract serviceName: string with get, set
    abstract uriBuilderName: string with get, set
    abstract jsonResultsAdapter: JsonResultsAdapter with get, set
    abstract useJsonp: bool with get, set
    abstract using: config: DataServiceOptions -> DataService

type [<AllowNullLiteral>] DataServiceStatic =
    [<EmitConstructor>] abstract Create: config: DataServiceOptions -> DataService

type [<AllowNullLiteral>] DataServiceOptions =
    abstract serviceName: string option with get, set
    abstract adapterName: string option with get, set
    abstract uriBuilderName: string option with get, set
    abstract hasServerMetadata: bool option with get, set
    abstract jsonResultsAdapter: JsonResultsAdapter option with get, set
    abstract useJsonp: bool option with get, set

type [<AllowNullLiteral>] DataServiceAdapter =
    abstract checkForRecomposition: interfaceInitializedArgs: {| interfaceName: string; isDefault: bool |} -> unit
    abstract initialize: unit -> unit
    abstract fetchMetadata: metadataStore: MetadataStore * dataService: DataService -> Promise<obj option>
    abstract executeQuery: mappingContext: {| getUrl: unit -> string; query: EntityQuery; dataService: DataService |} -> Promise<obj option>
    abstract saveChanges: saveContext: {| resourceName: string; dataService: DataService |} * saveBundle: Object -> Promise<SaveResult>
    abstract JsonResultsAdapter: JsonResultsAdapter with get, set

type [<AllowNullLiteral>] DataServiceAdapterStatic =
    [<EmitConstructor>] abstract Create: unit -> DataServiceAdapter

type [<AllowNullLiteral>] DeletedEntityKey =
    abstract entityTypeName: string with get, set
    abstract keyValues: ResizeArray<obj option> with get, set

type [<AllowNullLiteral>] DeletedEntityKeyStatic =
    [<EmitConstructor>] abstract Create: unit -> DeletedEntityKey

type [<AllowNullLiteral>] JsonResultsAdapter =
    abstract name: string with get, set
    abstract extractResults: (JsonResultsAdapterExtractResults -> JsonResultsAdapterExtractResults) with get, set
    abstract extractSaveResults: (JsonResultsAdapterExtractResults -> ResizeArray<obj option>) with get, set
    abstract extractKeyMappings: (JsonResultsAdapterExtractResults -> ResizeArray<KeyMapping>) with get, set
    abstract extractDeletedKeys: (JsonResultsAdapterExtractResults -> ResizeArray<DeletedEntityKey>) with get, set
    abstract visitNode: (JsonResultsAdapterExtractResults -> QueryContext -> NodeContext -> {| entityType: EntityType option; nodeId: obj option; nodeRefId: obj option; ignore: bool option |}) with get, set

type [<AllowNullLiteral>] JsonResultsAdapterStatic =
    [<EmitConstructor>] abstract Create: config: JsonResultsAdapterStaticConfig -> JsonResultsAdapter

type [<AllowNullLiteral>] JsonResultsAdapterStaticConfig =
    abstract name: string with get, set
    abstract extractResults: (JsonResultsAdapterExtractResults -> JsonResultsAdapterExtractResults) option with get, set
    abstract extractSaveResults: (JsonResultsAdapterExtractResults -> ResizeArray<obj option>) option with get, set
    abstract extractKeyMappings: (JsonResultsAdapterExtractResults -> ResizeArray<KeyMapping>) option with get, set
    abstract extractDeletedKeys: (JsonResultsAdapterExtractResults -> ResizeArray<DeletedEntityKey>) option with get, set
    abstract visitNode: (JsonResultsAdapterExtractResults -> QueryContext -> NodeContext -> {| entityType: EntityType option; nodeId: obj option; nodeRefId: obj option; ignore: bool option |}) with get, set

type [<AllowNullLiteral>] QueryContext =
    abstract url: string with get, set
    abstract query: U2<EntityQuery, string> with get, set
    abstract entityManager: EntityManager with get, set
    abstract dataService: DataService with get, set
    abstract queryOptions: QueryOptions with get, set

type [<AllowNullLiteral>] NodeContext =
    abstract nodeType: string with get, set
    abstract propertyName: string with get, set

type [<AllowNullLiteral>] DataTypeSymbol =
    inherit Core.EnumSymbol
    abstract defaultValue: obj option with get, set
    abstract isDate: bool option with get, set
    abstract isFloat: bool option with get, set
    abstract isInteger: bool option with get, set
    abstract isNumeric: bool option with get, set
    abstract quoteJsonOData: bool option with get, set
    abstract validatorCtor: (obj option -> Validator) with get, set
    /// Function to convert a value from string to this DataType.  Note that this will be called each time a property is changed, so make it fast.
    abstract parse: (obj option -> (string) option -> obj option) option with get, set
    /// Function to format this DataType for OData queries.
    abstract fmtOData: (obj option -> obj option) with get, set
    /// Optional function to get the next value for key generation, if this datatype is used as a key.  Uses an internal table of previous values.
    abstract getNext: (unit -> obj option) option with get, set
    /// Optional function to normalize a data value for comparison, if its value cannot be used directly.  Note that this will be called each time a property is changed, so make it fast.
    abstract normalize: (obj option -> obj option) option with get, set
    /// Optional function to get the next value when the datatype is used as a concurrency property.
    abstract getConcurrencyValue: (obj option -> obj option) option with get, set
    /// Optional function to convert a raw (server) value from string to this DataType.
    abstract parseRawValue: (obj option -> obj option) option with get, set

type [<AllowNullLiteral>] DataTypeSymbolStatic =
    [<EmitConstructor>] abstract Create: unit -> DataTypeSymbol

type [<AllowNullLiteral>] DataType =
    inherit Core.IEnum
    abstract Binary: DataTypeSymbol with get, set
    abstract Boolean: DataTypeSymbol with get, set
    abstract Byte: DataTypeSymbol with get, set
    abstract DateTime: DataTypeSymbol with get, set
    abstract DateTimeOffset: DataTypeSymbol with get, set
    abstract Decimal: DataTypeSymbol with get, set
    abstract Double: DataTypeSymbol with get, set
    abstract Guid: DataTypeSymbol with get, set
    abstract Int16: DataTypeSymbol with get, set
    abstract Int32: DataTypeSymbol with get, set
    abstract Int64: DataTypeSymbol with get, set
    abstract Single: DataTypeSymbol with get, set
    abstract String: DataTypeSymbol with get, set
    abstract Time: DataTypeSymbol with get, set
    abstract Undefined: DataTypeSymbol with get, set
    abstract constants: {| nextNumber: float; nextNumberIncrement: float; stringPrefix: string |} with get, set
    abstract fromEdmDataType: typeName: string -> DataTypeSymbol
    abstract fromValue: ``val``: obj option -> DataTypeSymbol
    abstract getComparableFn: dataType: DataTypeSymbol -> (obj option -> obj option)
    abstract parseDateAsUTC: source: obj option -> DateTime
    abstract parseDateFromServer: date: obj option -> DateTime
    abstract parseRawValue: ``val``: obj option * ?dataType: DataTypeSymbol -> obj option
    abstract parseTimeFromServer: source: obj option -> string

type [<AllowNullLiteral>] EntityActionSymbol =
    inherit Core.EnumSymbol

type [<AllowNullLiteral>] EntityActionSymbolStatic =
    [<EmitConstructor>] abstract Create: unit -> EntityActionSymbol

type [<AllowNullLiteral>] EntityAction =
    inherit Core.IEnum
    abstract AcceptChanges: EntityActionSymbol with get, set
    abstract Attach: EntityActionSymbol with get, set
    abstract AttachOnImport: EntityActionSymbol with get, set
    abstract AttachOnQuery: EntityActionSymbol with get, set
    abstract Clear: EntityActionSymbol with get, set
    abstract Detach: EntityActionSymbol with get, set
    abstract EntityStateChange: EntityActionSymbol with get, set
    abstract MergeOnImport: EntityActionSymbol with get, set
    abstract MergeOnSave: EntityActionSymbol with get, set
    abstract MergeOnQuery: EntityActionSymbol with get, set
    abstract PropertyChange: EntityActionSymbol with get, set
    abstract RejectChanges: EntityActionSymbol with get, set

type [<AllowNullLiteral>] EntityAspect =
    abstract entity: Entity with get, set
    abstract entityManager: EntityManager with get, set
    abstract entityState: EntityStateSymbol with get, set
    abstract isBeingSaved: bool with get, set
    abstract originalValues: Object with get, set
    abstract extraMetadata: Object with get, set
    abstract propertyChanged: PropertyChangedEvent with get, set
    abstract validationErrorsChanged: ValidationErrorsChangedEvent with get, set
    abstract acceptChanges: unit -> unit
    abstract addValidationError: validationError: ValidationError -> unit
    abstract clearValidationErrors: unit -> unit
    abstract getKey: ?forceRefresh: bool -> EntityKey
    abstract getValidationErrors: unit -> ResizeArray<ValidationError>
    abstract getValidationErrors: property: string -> ResizeArray<ValidationError>
    abstract getValidationErrors: property: IProperty -> ResizeArray<ValidationError>
    abstract hasValidationErrors: bool with get, set
    abstract isNavigationPropertyLoaded: navigationProperty: string -> bool
    abstract isNavigationPropertyLoaded: navigationProperty: NavigationProperty -> bool
    abstract loadNavigationProperty: navigationProperty: string * ?callback: Function * ?errorCallback: Function -> Promise<QueryResult>
    abstract loadNavigationProperty: navigationProperty: NavigationProperty * ?callback: Function * ?errorCallback: Function -> Promise<QueryResult>
    abstract rejectChanges: unit -> unit
    abstract removeValidationError: validator: Validator -> unit
    abstract removeValidationError: validator: Validator * property: DataProperty -> unit
    abstract removeValidationError: validator: Validator * property: NavigationProperty -> unit
    abstract removeValidationError: validationError: ValidationError -> unit
    abstract setAdded: unit -> unit
    abstract setDeleted: unit -> unit
    abstract setDetached: unit -> unit
    abstract setModified: unit -> unit
    abstract setUnchanged: unit -> unit
    abstract setEntityState: entityState: EntityStateSymbol -> unit
    abstract validateEntity: unit -> bool
    abstract validateProperty: property: string * ?context: obj -> bool
    abstract validateProperty: property: DataProperty * ?context: obj -> bool
    abstract validateProperty: property: NavigationProperty * ?context: obj -> bool

type [<AllowNullLiteral>] EntityAspectStatic =
    [<EmitConstructor>] abstract Create: unit -> EntityAspect

type [<AllowNullLiteral>] PropertyChangedEventArgs =
    abstract entity: Entity with get, set
    abstract property: IProperty with get, set
    abstract propertyName: string with get, set
    abstract oldValue: obj option with get, set
    abstract newValue: obj option with get, set
    abstract parent: obj option with get, set

type [<AllowNullLiteral>] PropertyChangedEventArgsStatic =
    [<EmitConstructor>] abstract Create: unit -> PropertyChangedEventArgs

type [<AllowNullLiteral>] PropertyChangedEvent =
    inherit Core.Event
    abstract subscribe: ?callback: (PropertyChangedEventArgs -> unit) -> float

type [<AllowNullLiteral>] PropertyChangedEventStatic =
    [<EmitConstructor>] abstract Create: name: string * publisher: obj option * ?defaultErrorCallback: ErrorCallback -> PropertyChangedEvent

type [<AllowNullLiteral>] ValidationErrorsChangedEventArgs =
    abstract entity: Entity with get, set
    abstract added: ResizeArray<ValidationError> with get, set
    abstract removed: ResizeArray<ValidationError> with get, set

type [<AllowNullLiteral>] ValidationErrorsChangedEventArgsStatic =
    [<EmitConstructor>] abstract Create: unit -> ValidationErrorsChangedEventArgs

type [<AllowNullLiteral>] ValidationErrorsChangedEvent =
    inherit Core.Event
    abstract subscribe: ?callback: (ValidationErrorsChangedEventArgs -> unit) -> float

type [<AllowNullLiteral>] ValidationErrorsChangedEventStatic =
    [<EmitConstructor>] abstract Create: name: string * publisher: obj option * ?defaultErrorCallback: ErrorCallback -> ValidationErrorsChangedEvent

type [<AllowNullLiteral>] EntityKey =
    abstract equals: entityKey: EntityKey -> bool
    abstract entityType: EntityType with get, set
    abstract values: ResizeArray<obj option> with get, set

type [<AllowNullLiteral>] EntityKeyStatic =
    [<EmitConstructor>] abstract Create: entityType: EntityType * keyValue: obj option -> EntityKey
    [<EmitConstructor>] abstract Create: entityType: EntityType * keyValues: ResizeArray<obj option> -> EntityKey
    abstract equals: k1: EntityKey * k2: EntityKey -> bool

type [<AllowNullLiteral>] EntityByKeyResult =
    abstract entity: Entity with get, set
    abstract entityKey: EntityKey with get, set
    abstract fromCache: bool with get, set

type [<AllowNullLiteral>] ExportEntitiesOptions =
    abstract asString: bool with get, set
    abstract includeMetadata: bool with get, set

type [<AllowNullLiteral>] EntityManager =
    abstract dataService: DataService with get, set
    abstract keyGeneratorCtor: Function with get, set
    abstract metadataStore: MetadataStore with get, set
    abstract queryOptions: QueryOptions with get, set
    abstract saveOptions: SaveOptions with get, set
    abstract serviceName: string with get, set
    abstract validationOptions: ValidationOptions with get, set
    abstract entityChanged: EntityChangedEvent with get, set
    abstract hasChangesChanged: HasChangesChangedEvent with get, set
    abstract validationErrorsChanged: ValidationErrorsChangedEvent with get, set
    abstract acceptChanges: unit -> unit
    abstract addEntity: entity: Entity -> Entity
    abstract attachEntity: entity: Entity * ?entityState: EntityStateSymbol * ?mergeStrategy: MergeStrategySymbol -> Entity
    abstract clear: unit -> unit
    abstract createEmptyCopy: unit -> EntityManager
    abstract createEntity: typeName: string * ?config: EntityManagerCreateEntityConfig * ?entityState: EntityStateSymbol * ?mergeStrategy: MergeStrategySymbol -> Entity
    abstract createEntity: entityType: EntityType * ?config: EntityManagerCreateEntityConfig_ * ?entityState: EntityStateSymbol * ?mergeStrategy: MergeStrategySymbol -> Entity
    abstract detachEntity: entity: Entity -> bool
    abstract executeQuery: query: string * ?callback: ExecuteQuerySuccessCallback * ?errorCallback: ExecuteQueryErrorCallback -> Promise<QueryResult>
    abstract executeQuery: query: EntityQuery * ?callback: ExecuteQuerySuccessCallback * ?errorCallback: ExecuteQueryErrorCallback -> Promise<QueryResult>
    abstract executeQueryLocally: query: EntityQuery -> ResizeArray<Entity>
    abstract exportEntities: ?entities: ResizeArray<Entity> * ?includeMetadata: bool -> string
    abstract exportEntities: ?entities: ResizeArray<Entity> * ?options: ExportEntitiesOptions -> obj option
    abstract fetchEntityByKey: typeName: string * keyValue: obj option * ?checkLocalCacheFirst: bool -> Promise<EntityByKeyResult>
    abstract fetchEntityByKey: typeName: string * keyValues: ResizeArray<obj option> * ?checkLocalCacheFirst: bool -> Promise<EntityByKeyResult>
    abstract fetchEntityByKey: entityKey: EntityKey -> Promise<EntityByKeyResult>
    abstract fetchMetadata: ?callback: (obj option -> unit) * ?errorCallback: Core.ErrorCallback -> Promise<obj option>
    abstract generateTempKeyValue: entity: Entity -> obj option
    abstract getChanges: unit -> ResizeArray<Entity>
    abstract getChanges: entityTypeName: string -> ResizeArray<Entity>
    abstract getChanges: entityTypeNames: ResizeArray<string> -> ResizeArray<Entity>
    abstract getChanges: entityType: EntityType -> ResizeArray<Entity>
    abstract getChanges: entityTypes: ResizeArray<EntityType> -> ResizeArray<Entity>
    abstract getEntities: entityTypeName: string * ?entityState: EntityStateSymbol -> ResizeArray<Entity>
    abstract getEntities: ?entityTypeNames: ResizeArray<string> * ?entityState: EntityStateSymbol -> ResizeArray<Entity>
    abstract getEntities: ?entityTypeName: string * ?entityStates: ResizeArray<EntityStateSymbol> -> ResizeArray<Entity>
    abstract getEntities: ?entityTypeNames: ResizeArray<string> * ?entityStates: ResizeArray<EntityStateSymbol> -> ResizeArray<Entity>
    abstract getEntities: entityType: EntityType * ?entityState: EntityStateSymbol -> ResizeArray<Entity>
    abstract getEntities: ?entityTypes: ResizeArray<EntityType> * ?entityState: EntityStateSymbol -> ResizeArray<Entity>
    abstract getEntities: ?entityType: EntityType * ?entityStates: ResizeArray<EntityStateSymbol> -> ResizeArray<Entity>
    abstract getEntities: ?entityTypes: ResizeArray<EntityType> * ?entityStates: ResizeArray<EntityStateSymbol> -> ResizeArray<Entity>
    abstract getEntityByKey: typeName: string * keyValue: obj option -> Entity
    abstract getEntityByKey: typeName: string * keyValues: ResizeArray<obj option> -> Entity
    abstract getEntityByKey: entityKey: EntityKey -> Entity
    abstract hasChanges: unit -> bool
    abstract hasChanges: entityTypeName: string -> bool
    abstract hasChanges: entityTypeNames: ResizeArray<string> -> bool
    abstract hasChanges: entityType: EntityType -> bool
    abstract hasChanges: entityTypes: ResizeArray<EntityType> -> bool
    abstract importEntities: exportedString: string * ?config: {| mergeAdds: bool option; mergeStrategy: MergeStrategySymbol option; metadataVersionFn: (obj option -> unit) option |} -> {| entities: ResizeArray<Entity>; tempKeyMapping: EntityManagerImportEntitiesTempKeyMapping |}
    abstract importEntities: exportedData: Object * ?config: {| mergeAdds: bool option; mergeStrategy: MergeStrategySymbol option; metadataVersionFn: (obj option -> unit) option |} -> {| entities: ResizeArray<Entity>; tempKeyMapping: EntityManagerImportEntitiesTempKeyMapping |}
    abstract rejectChanges: unit -> ResizeArray<Entity>
    abstract saveChanges: ?entities: ResizeArray<Entity> * ?saveOptions: SaveOptions * ?callback: SaveChangesSuccessCallback * ?errorCallback: SaveChangesErrorCallback -> Promise<SaveResult>
    abstract setProperties: config: EntityManagerProperties -> unit

type [<AllowNullLiteral>] EntityManagerCreateEntityConfig =
    interface end

type [<AllowNullLiteral>] EntityManagerCreateEntityConfig_ =
    interface end

type [<AllowNullLiteral>] EntityManagerStatic =
    [<EmitConstructor>] abstract Create: ?config: EntityManagerOptions -> EntityManager
    [<EmitConstructor>] abstract Create: ?config: string -> EntityManager
    abstract importEntities: exportedString: string * ?config: {| mergeAdds: bool option; mergeStrategy: MergeStrategySymbol option; metadataVersionFn: (obj option -> unit) option |} -> EntityManager
    abstract importEntities: exportedData: Object * ?config: {| mergeAdds: bool option; mergeStrategy: MergeStrategySymbol option; metadataVersionFn: (obj option -> unit) option |} -> EntityManager

type [<AllowNullLiteral>] EntityManagerOptions =
    abstract serviceName: string option with get, set
    abstract dataService: DataService option with get, set
    abstract metadataStore: MetadataStore option with get, set
    abstract queryOptions: QueryOptions option with get, set
    abstract saveOptions: SaveOptions option with get, set
    abstract validationOptions: ValidationOptions option with get, set
    abstract keyGeneratorCtor: Function option with get, set

type [<AllowNullLiteral>] EntityManagerProperties =
    abstract serviceName: string option with get, set
    abstract dataService: DataService option with get, set
    abstract metadataStore: MetadataStore option with get, set
    abstract queryOptions: QueryOptions option with get, set
    abstract saveOptions: SaveOptions option with get, set
    abstract validationOptions: ValidationOptions option with get, set
    abstract keyGeneratorCtor: Function option with get, set

type [<AllowNullLiteral>] ExecuteQuerySuccessCallback =
    [<Emit("$0($1...)")>] abstract Invoke: data: QueryResult -> unit

type [<AllowNullLiteral>] ExecuteQueryErrorCallback =
    [<Emit("$0($1...)")>] abstract Invoke: error: ExecuteQueryErrorCallbackInvokeError -> unit

type [<AllowNullLiteral>] ExecuteQueryErrorCallbackInvokeError =
    abstract query: EntityQuery with get, set
    abstract httpResponse: HttpResponse with get, set
    abstract entityManager: EntityManager with get, set
    abstract message: string option with get, set
    abstract stack: string option with get, set

type [<AllowNullLiteral>] SaveChangesSuccessCallback =
    [<Emit("$0($1...)")>] abstract Invoke: saveResult: SaveResult -> unit

type [<AllowNullLiteral>] EntityError =
    abstract entity: Entity with get, set
    abstract errorMessage: string with get, set
    abstract errorName: string with get, set
    abstract isServerError: bool with get, set
    abstract propertyName: string with get, set

type [<AllowNullLiteral>] SaveChangesErrorCallback =
    [<Emit("$0($1...)")>] abstract Invoke: error: SaveChangesErrorCallbackInvokeError -> unit

type [<AllowNullLiteral>] SaveChangesErrorCallbackInvokeError =
    abstract entityErrors: ResizeArray<EntityError> with get, set
    abstract httpResponse: HttpResponse with get, set
    abstract message: string with get, set
    abstract stack: string option with get, set
    abstract status: float option with get, set

type [<AllowNullLiteral>] EntityChangedEventArgs =
    abstract entity: Entity with get, set
    abstract entityAction: EntityActionSymbol with get, set
    abstract args: Object with get, set

type [<AllowNullLiteral>] EntityChangedEventArgsStatic =
    [<EmitConstructor>] abstract Create: unit -> EntityChangedEventArgs

type [<AllowNullLiteral>] EntityChangedEvent =
    inherit Core.Event
    abstract subscribe: ?callback: (EntityChangedEventArgs -> unit) -> float

type [<AllowNullLiteral>] EntityChangedEventStatic =
    [<EmitConstructor>] abstract Create: name: string * publisher: obj option * ?defaultErrorCallback: ErrorCallback -> EntityChangedEvent

type [<AllowNullLiteral>] HasChangesChangedEventArgs =
    abstract entityManager: EntityManager with get, set
    abstract hasChanges: bool with get, set

type [<AllowNullLiteral>] HasChangesChangedEventArgsStatic =
    [<EmitConstructor>] abstract Create: unit -> HasChangesChangedEventArgs

type [<AllowNullLiteral>] HasChangesChangedEvent =
    inherit Core.Event
    abstract subscribe: ?callback: (HasChangesChangedEventArgs -> unit) -> float

type [<AllowNullLiteral>] HasChangesChangedEventStatic =
    [<EmitConstructor>] abstract Create: name: string * publisher: obj option * ?defaultErrorCallback: ErrorCallback -> HasChangesChangedEvent

type [<AllowNullLiteral>] EntityQuery =
    abstract entityManager: EntityManager with get, set
    abstract orderByClause: OrderByClause with get, set
    abstract parameters: Object with get, set
    abstract queryOptions: QueryOptions with get, set
    abstract resourceName: string with get, set
    abstract resultEntityType: EntityType with get, set
    abstract skipCount: float with get, set
    abstract takeCount: float with get, set
    abstract wherePredicate: Predicate with get, set
    abstract execute: ?callback: ExecuteQuerySuccessCallback * ?errorCallback: ExecuteQueryErrorCallback -> Promise<QueryResult>
    abstract executeLocally: unit -> ResizeArray<Entity>
    abstract expand: propertyPaths: ResizeArray<string> -> EntityQuery
    abstract expand: propertyPaths: string -> EntityQuery
    abstract from: resourceName: string -> EntityQuery
    abstract inlineCount: ?enabled: bool -> EntityQuery
    abstract noTracking: ?enabled: bool -> EntityQuery
    abstract orderBy: propertyPaths: string * ?isDescending: bool -> EntityQuery
    abstract orderBy: propertyPaths: ResizeArray<string> * ?isDescending: bool -> EntityQuery
    abstract orderByDesc: propertyPaths: string -> EntityQuery
    abstract orderByDesc: propertyPaths: ResizeArray<string> -> EntityQuery
    abstract select: propertyPaths: string -> EntityQuery
    abstract select: propertyPaths: ResizeArray<string> -> EntityQuery
    abstract skip: count: float -> EntityQuery
    abstract take: count: float -> EntityQuery
    abstract top: count: float -> EntityQuery
    abstract toType: typeName: string -> EntityQuery
    abstract toType: ``type``: EntityType -> EntityQuery
    abstract using: obj: EntityManager -> EntityQuery
    abstract using: obj: DataService -> EntityQuery
    abstract using: obj: JsonResultsAdapter -> EntityQuery
    abstract using: obj: QueryOptions -> EntityQuery
    abstract using: obj: MergeStrategySymbol -> EntityQuery
    abstract using: obj: FetchStrategySymbol -> EntityQuery
    abstract where: predicate: Predicate -> EntityQuery
    abstract where: property: string * operator: string * value: obj option -> EntityQuery
    abstract where: property: string * operator: FilterQueryOpSymbol * value: obj option -> EntityQuery
    abstract where: property: string * filterop: FilterQueryOpSymbol * property2: string * filterop2: FilterQueryOpSymbol * value: obj option -> EntityQuery
    abstract where: property: string * filterop: string * property2: string * filterop2: string * value: obj option -> EntityQuery
    abstract where: predicate: FilterQueryOpSymbol -> EntityQuery
    abstract where: anArray: IRecursiveArray<U4<string, float, FilterQueryOpSymbol, Predicate>> -> EntityQuery
    abstract withParameters: ``params``: Object -> EntityQuery
    abstract toJSON: unit -> string

type [<AllowNullLiteral>] EntityQueryStatic =
    [<EmitConstructor>] abstract Create: ?resourceName: string -> EntityQuery
    /// Create query from an expression tree
    [<EmitConstructor>] abstract Create: tree: Object -> EntityQuery
    abstract from: resourceName: string -> EntityQuery
    abstract fromEntities: entity: Entity -> EntityQuery
    abstract fromEntities: entities: ResizeArray<Entity> -> EntityQuery
    abstract fromEntityKey: entityKey: EntityKey -> EntityQuery
    abstract fromEntityNavigation: entity: Entity * navigationProperty: NavigationProperty -> EntityQuery

type [<AllowNullLiteral>] OrderByClause =
    interface end

type [<AllowNullLiteral>] EntityStateSymbol =
    inherit Core.EnumSymbol
    abstract isAdded: unit -> bool
    abstract isAddedModifiedOrDeleted: unit -> bool
    abstract isDeleted: unit -> bool
    abstract isDetached: unit -> bool
    abstract isModified: unit -> bool
    abstract isUnchanged: unit -> bool
    abstract isUnchangedOrModified: unit -> bool

type [<AllowNullLiteral>] EntityStateSymbolStatic =
    [<EmitConstructor>] abstract Create: unit -> EntityStateSymbol

type [<AllowNullLiteral>] EntityState =
    inherit Core.IEnum
    abstract Added: EntityStateSymbol with get, set
    abstract Deleted: EntityStateSymbol with get, set
    abstract Detached: EntityStateSymbol with get, set
    abstract Modified: EntityStateSymbol with get, set
    abstract Unchanged: EntityStateSymbol with get, set

type [<AllowNullLiteral>] EntityType =
    inherit IStructuralType
    abstract autoGeneratedKeyType: AutoGeneratedKeyType with get, set
    abstract baseEntityType: EntityType with get, set
    abstract complexProperties: ResizeArray<DataProperty> with get, set
    abstract concurrencyProperties: ResizeArray<DataProperty> with get, set
    abstract dataProperties: ResizeArray<DataProperty> with get, set
    abstract defaultResourceName: string with get, set
    abstract foreignKeyProperties: ResizeArray<DataProperty> with get, set
    abstract isAbstract: bool with get, set
    abstract keyProperties: ResizeArray<DataProperty> with get, set
    abstract metadataStore: MetadataStore with get, set
    abstract name: string with get, set
    abstract ``namespace``: string with get, set
    abstract navigationProperties: ResizeArray<NavigationProperty> with get, set
    abstract shortName: string with get, set
    abstract unmappedProperties: ResizeArray<DataProperty> with get, set
    abstract validators: ResizeArray<Validator> with get, set
    abstract custom: obj option with get, set
    abstract addProperty: property: IProperty -> unit
    abstract addValidator: validator: Validator * ?property: IProperty -> unit
    abstract createEntity: ?initialValues: Object -> Entity
    abstract getCtor: unit -> Function
    abstract getDataProperty: propertyName: string -> DataProperty
    abstract getNavigationProperty: propertyName: string -> NavigationProperty
    abstract getProperties: unit -> ResizeArray<IProperty>
    abstract getProperty: propertyPath: string * ?throwIfNotFound: bool -> IProperty
    abstract getPropertyNames: unit -> ResizeArray<string>
    abstract getSelfAndSubtypes: unit -> ResizeArray<EntityType>
    abstract isSubtypeOf: entityType: EntityType -> bool
    abstract setProperties: config: EntityTypeProperties -> unit
    abstract toString: unit -> string

type [<AllowNullLiteral>] EntityTypeStatic =
    [<EmitConstructor>] abstract Create: config: MetadataStore -> EntityType
    [<EmitConstructor>] abstract Create: config: EntityTypeOptions -> EntityType

type [<AllowNullLiteral>] EntityTypeOptions =
    abstract shortName: string option with get, set
    abstract ``namespace``: string option with get, set
    abstract autoGeneratedKeyType: AutoGeneratedKeyType option with get, set
    abstract defaultResourceName: string option with get, set
    abstract dataProperties: ResizeArray<DataProperty> option with get, set
    abstract navigationProperties: ResizeArray<NavigationProperty> option with get, set

type [<AllowNullLiteral>] EntityTypeProperties =
    abstract autoGeneratedKeyType: AutoGeneratedKeyType option with get, set
    abstract defaultResourceName: string option with get, set
    abstract serializerFn: (DataProperty -> obj option -> obj option) option with get, set

type [<AllowNullLiteral>] FetchStrategySymbol =
    inherit Core.EnumSymbol

type [<AllowNullLiteral>] FetchStrategySymbolStatic =
    [<EmitConstructor>] abstract Create: unit -> FetchStrategySymbol

type [<AllowNullLiteral>] FetchStrategy =
    inherit Core.IEnum
    abstract FromLocalCache: FetchStrategySymbol with get, set
    abstract FromServer: FetchStrategySymbol with get, set

type [<AllowNullLiteral>] FilterQueryOpSymbol =
    inherit Core.EnumSymbol

type [<AllowNullLiteral>] FilterQueryOpSymbolStatic =
    [<EmitConstructor>] abstract Create: unit -> FilterQueryOpSymbol

type [<AllowNullLiteral>] FilterQueryOp =
    inherit Core.IEnum
    abstract Contains: FilterQueryOpSymbol with get, set
    abstract EndsWith: FilterQueryOpSymbol with get, set
    abstract Equals: FilterQueryOpSymbol with get, set
    abstract GreaterThan: FilterQueryOpSymbol with get, set
    abstract GreaterThanOrEqual: FilterQueryOpSymbol with get, set
    abstract IsTypeOf: FilterQueryOpSymbol with get, set
    abstract LessThan: FilterQueryOpSymbol with get, set
    abstract LessThanOrEqual: FilterQueryOpSymbol with get, set
    abstract NotEquals: FilterQueryOpSymbol with get, set
    abstract StartsWith: FilterQueryOpSymbol with get, set
    abstract Any: FilterQueryOpSymbol with get, set
    abstract All: FilterQueryOpSymbol with get, set

type [<AllowNullLiteral>] LocalQueryComparisonOptions =
    abstract setAsDefault: unit -> unit

type [<AllowNullLiteral>] LocalQueryComparisonOptionsStatic =
    abstract caseInsensitiveSQL: LocalQueryComparisonOptions with get, set
    abstract defaultInstance: LocalQueryComparisonOptions with get, set
    [<EmitConstructor>] abstract Create: config: {| name: string option; isCaseSensitive: bool option; usesSql92CompliantStringComparison: bool option |} -> LocalQueryComparisonOptions

type [<AllowNullLiteral>] MergeStrategySymbol =
    inherit Core.EnumSymbol

type [<AllowNullLiteral>] MergeStrategySymbolStatic =
    [<EmitConstructor>] abstract Create: unit -> MergeStrategySymbol

type [<AllowNullLiteral>] MergeStrategy =
    inherit Core.IEnum
    abstract OverwriteChanges: MergeStrategySymbol with get, set
    abstract PreserveChanges: MergeStrategySymbol with get, set
    abstract SkipMerge: MergeStrategySymbol with get, set
    abstract Disallowed: MergeStrategySymbol with get, set

type [<AllowNullLiteral>] MetadataStore =
    abstract namingConvention: NamingConvention with get, set
    abstract addDataService: dataService: DataService * ?shouldOverwrite: bool -> unit
    abstract addEntityType: structuralType: U2<EntityType, ComplexType> -> unit
    abstract exportMetadata: unit -> string
    abstract fetchMetadata: dataService: string * ?callback: (obj option -> unit) * ?errorCallback: Core.ErrorCallback -> Promise<obj option>
    abstract fetchMetadata: dataService: DataService * ?callback: (obj option -> unit) * ?errorCallback: Core.ErrorCallback -> Promise<obj option>
    abstract getDataService: serviceName: string -> DataService
    abstract getEntityType: entityTypeName: string * ?okIfNotFound: bool -> U2<EntityType, ComplexType>
    abstract getEntityTypes: unit -> ResizeArray<U2<EntityType, ComplexType>>
    abstract hasMetadataFor: serviceName: string -> bool
    abstract importMetadata: exportedString: string * ?allowMerge: bool -> MetadataStore
    abstract isEmpty: unit -> bool
    abstract registerEntityTypeCtor: entityTypeName: string * entityCtor: Function * ?initializationFn: (Entity -> unit) * ?noTrackingFn: (Object -> EntityType -> Object) -> unit
    abstract trackUnmappedType: entityCtor: Function * ?interceptor: Function -> unit
    abstract setEntityTypeForResourceName: resourceName: string * entityType: EntityType -> unit
    abstract setEntityTypeForResourceName: resourceName: string * entityTypeName: string -> unit
    abstract getEntityTypeNameForResourceName: resourceName: string -> string
    abstract setProperties: config: {| name: string option; serializerFn: Function option |} -> unit

type [<AllowNullLiteral>] MetadataStoreStatic =
    [<EmitConstructor>] abstract Create: unit -> MetadataStore
    [<EmitConstructor>] abstract Create: ?config: MetadataStoreOptions -> MetadataStore
    abstract importMetadata: exportedString: string -> MetadataStore
    abstract normalizeTypeName: typeName: string -> string

type [<AllowNullLiteral>] MetadataStoreOptions =
    abstract namingConvention: NamingConvention option with get, set
    abstract localQueryComparisonOptions: LocalQueryComparisonOptions option with get, set

type [<AllowNullLiteral>] NamingConvention =
    abstract clientPropertyNameToServer: clientPropertyName: string -> string
    abstract clientPropertyNameToServer: clientPropertyName: string * property: IProperty -> string
    abstract serverPropertyNameToClient: serverPropertyName: string -> string
    abstract serverPropertyNameToClient: serverPropertyName: string * property: IProperty -> string
    abstract setAsDefault: unit -> NamingConvention

type [<AllowNullLiteral>] NamingConventionStatic =
    abstract camelCase: NamingConvention with get, set
    abstract defaultInstance: NamingConvention with get, set
    abstract none: NamingConvention with get, set
    [<EmitConstructor>] abstract Create: config: NamingConventionOptions -> NamingConvention

type [<AllowNullLiteral>] NamingConventionOptions =
    abstract serverPropertyNameToClient: (string -> string) option with get, set
    abstract clientPropertyNameToServer: (string -> string) option with get, set

type [<AllowNullLiteral>] NavigationProperty =
    inherit IProperty
    abstract associationName: string with get, set
    abstract entityType: EntityType with get, set
    abstract foreignKeyNames: ResizeArray<string> with get, set
    abstract inverse: NavigationProperty with get, set
    abstract isDataProperty: bool with get, set
    abstract isNavigationProperty: bool with get, set
    abstract isScalar: bool with get, set
    abstract name: string with get, set
    abstract nameOnServer: string with get, set
    abstract displayName: string with get, set
    abstract parentType: U2<EntityType, ComplexType> with get, set
    abstract relatedDataProperties: ResizeArray<DataProperty> with get, set
    abstract validators: ResizeArray<Validator> with get, set
    abstract invForeignKeyNames: ResizeArray<string> option with get, set
    abstract invForeignKeyNamesOnServer: ResizeArray<string> option with get, set
    abstract custom: obj option with get, set

type [<AllowNullLiteral>] NavigationPropertyStatic =
    [<EmitConstructor>] abstract Create: config: NavigationPropertyOptions -> NavigationProperty

type [<AllowNullLiteral>] NavigationPropertyOptions =
    abstract name: string option with get, set
    abstract nameOnServer: string option with get, set
    abstract entityTypeName: string with get, set
    abstract isScalar: bool option with get, set
    abstract associationName: string option with get, set
    abstract foreignKeyNames: ResizeArray<string> option with get, set
    abstract foreignKeyNamesOnServer: ResizeArray<string> option with get, set
    abstract validators: ResizeArray<Validator> option with get, set
    abstract invForeignKeyNames: ResizeArray<string> option with get, set
    abstract invForeignKeyNamesOnServer: ResizeArray<string> option with get, set

type [<AllowNullLiteral>] IRecursiveArray<'T> =
    [<EmitIndexer>] abstract Item: i: float -> U2<'T, IRecursiveArray<'T>> with get, set

type [<AllowNullLiteral>] Predicate =
    abstract ``and``: PredicateMethod with get, set
    abstract not: unit -> Predicate
    abstract ``or``: PredicateMethod with get, set
    abstract toFunction: unit -> Function
    abstract toString: unit -> string
    abstract validate: entityType: EntityType -> unit
    abstract toJSON: unit -> string

type [<AllowNullLiteral>] PredicateStatic =
    [<EmitConstructor>] abstract Create: unit -> Predicate
    [<EmitConstructor>] abstract Create: property: string * operator: string * value: obj option -> Predicate
    [<EmitConstructor>] abstract Create: property: string * operator: FilterQueryOpSymbol * value: obj option -> Predicate
    [<EmitConstructor>] abstract Create: property: string * operator: string * value: {| value: obj option; isLiteral: bool option; dataType: DataType option |} -> Predicate
    [<EmitConstructor>] abstract Create: property: string * operator: FilterQueryOpSymbol * value: {| value: obj option; isLiteral: bool option; dataType: DataType option |} -> Predicate
    [<EmitConstructor>] abstract Create: property: string * filterop: FilterQueryOpSymbol * property2: string * filterop2: FilterQueryOpSymbol * value: obj option -> Predicate
    [<EmitConstructor>] abstract Create: property: string * filterop: string * property2: string * filterop2: string * value: obj option -> Predicate
    [<EmitConstructor>] abstract Create: passthru: string -> Predicate
    [<EmitConstructor>] abstract Create: predicate: Predicate -> Predicate
    [<EmitConstructor>] abstract Create: anArray: IRecursiveArray<U4<string, float, FilterQueryOpSymbol, Predicate>> -> Predicate
    abstract ``and``: PredicateMethod with get, set
    abstract create: PredicateMethod with get, set
    abstract isPredicate: o: obj option -> bool
    abstract not: predicate: Predicate -> Predicate
    abstract ``or``: PredicateMethod with get, set

type [<AllowNullLiteral>] PredicateMethod =
    [<Emit("$0($1...)")>] abstract Invoke: predicates: ResizeArray<Predicate> -> Predicate
    [<Emit("$0($1...)")>] abstract Invoke: [<ParamArray>] predicates: Predicate[] -> Predicate
    [<Emit("$0($1...)")>] abstract Invoke: property: string * operator: string * value: obj option * ?valueIsLiteral: bool -> Predicate
    [<Emit("$0($1...)")>] abstract Invoke: property: string * operator: FilterQueryOpSymbol * value: obj option * ?valueIsLiteral: bool -> Predicate
    [<Emit("$0($1...)")>] abstract Invoke: property: string * filterop: FilterQueryOpSymbol * property2: string * filterop2: FilterQueryOpSymbol * value: obj option -> Predicate
    [<Emit("$0($1...)")>] abstract Invoke: property: string * filterop: string * property2: string * filterop2: string * value: obj option -> Predicate

type [<AllowNullLiteral>] QueryOptions =
    abstract fetchStrategy: FetchStrategySymbol with get, set
    abstract mergeStrategy: MergeStrategySymbol with get, set
    /// Whether query should return cached deleted entities (false by default)
    abstract includeDeleted: bool with get, set
    abstract setAsDefault: unit -> unit
    abstract using: config: QueryOptionsConfiguration -> QueryOptions
    abstract using: config: MergeStrategySymbol -> QueryOptions
    abstract using: config: FetchStrategySymbol -> QueryOptions

type [<AllowNullLiteral>] QueryOptionsStatic =
    abstract defaultInstance: QueryOptions with get, set
    [<EmitConstructor>] abstract Create: ?config: QueryOptionsConfiguration -> QueryOptions

type [<AllowNullLiteral>] QueryOptionsConfiguration =
    abstract fetchStrategy: FetchStrategySymbol option with get, set
    abstract mergeStrategy: MergeStrategySymbol option with get, set

type [<AllowNullLiteral>] HttpResponse =
    abstract config: obj option with get, set
    abstract data: ResizeArray<Entity> with get, set
    abstract error: obj option with get, set
    abstract saveContext: obj option with get, set
    abstract status: float with get, set
    abstract getHeaders: headerName: string -> string

type [<AllowNullLiteral>] QueryResult =
    /// Top level entities returned
    abstract results: ResizeArray<Entity> with get, set
    /// Query that was executed
    abstract query: EntityQuery with get, set
    /// Raw response from the server
    abstract httpResponse: HttpResponse with get, set
    /// EntityManager that executed the query
    abstract entityManager: EntityManager option with get, set
    /// Total number of results available on the server
    abstract inlineCount: float option with get, set
    /// All entities returned by the query.  Differs from results when an expand is used.
    abstract retrievedEntities: ResizeArray<Entity> option with get, set

type [<AllowNullLiteral>] SaveOptions =
    abstract allowConcurrentSaves: bool with get, set
    abstract resourceName: string with get, set
    abstract dataService: DataService with get, set
    abstract tag: Object with get, set
    abstract setAsDefault: unit -> SaveOptions
    abstract using: config: SaveOptionsConfiguration -> SaveOptions

type [<AllowNullLiteral>] SaveOptionsStatic =
    abstract defaultInstance: SaveOptions with get, set
    [<EmitConstructor>] abstract Create: ?config: {| allowConcurrentSaves: bool option; resourceName: string option; dataService: DataService option; tag: obj option |} -> SaveOptions

type [<AllowNullLiteral>] SaveOptionsConfiguration =
    abstract allowConcurrentSaves: bool option with get, set
    abstract resourceName: string option with get, set
    abstract dataService: DataService option with get, set
    abstract tag: Object option with get, set

type [<AllowNullLiteral>] SaveResult =
    abstract entities: ResizeArray<Entity> with get, set
    abstract keyMappings: ResizeArray<KeyMapping> with get, set
    abstract XHR: XMLHttpRequest with get, set

type [<AllowNullLiteral>] KeyMapping =
    abstract entityTypeName: string with get, set
    abstract tempValue: obj option with get, set
    abstract realValue: obj option with get, set

type [<AllowNullLiteral>] ValidationError =
    abstract key: string with get, set
    abstract context: obj option with get, set
    abstract errorMessage: string with get, set
    abstract property: IProperty with get, set
    abstract propertyName: string with get, set
    abstract validator: Validator with get, set
    abstract getKey: (Validator -> string -> string) with get, set

type [<AllowNullLiteral>] ValidationErrorStatic =
    [<EmitConstructor>] abstract Create: validator: Validator * context: obj option * errorMessage: string * key: string -> ValidationError

type [<AllowNullLiteral>] ValidationOptions =
    abstract validateOnAttach: bool with get, set
    abstract validateOnPropertyChange: bool with get, set
    abstract validateOnQuery: bool with get, set
    abstract validateOnSave: bool with get, set
    abstract setAsDefault: unit -> ValidationOptions
    abstract using: config: ValidationOptionsConfiguration -> ValidationOptions

type [<AllowNullLiteral>] ValidationOptionsStatic =
    abstract defaultInstance: ValidationOptions with get, set
    [<EmitConstructor>] abstract Create: ?config: ValidationOptionsConfiguration -> ValidationOptions

type [<AllowNullLiteral>] ValidationOptionsConfiguration =
    abstract validateOnAttach: bool option with get, set
    abstract validateOnSave: bool option with get, set
    abstract validateOnQuery: bool option with get, set
    abstract validateOnPropertyChange: bool option with get, set

type [<AllowNullLiteral>] Validator =
    abstract context: obj option with get, set
    abstract name: string with get, set
    /// <summary>Run this validator against the specified value.</summary>
    /// <param name="value">Value to validate</param>
    /// <param name="additionalContext">Any additional contextual information that the Validator can make use of.</param>
    /// <returns>A ValidationError if validation fails, null otherwise</returns>
    abstract validate: value: obj option * ?context: obj -> ValidationError
    /// Returns the message generated by the most recent execution of this Validator.
    abstract getMessage: unit -> string

type [<AllowNullLiteral>] ValidatorStatic =
    /// Map of standard error message templates keyed by validator name.
    abstract messageTemplates: obj option with get, set
    [<EmitConstructor>] abstract Create: name: string * validatorFn: ValidatorFunction * ?context: obj -> Validator
    abstract bool: unit -> Validator
    /// integer between 0 and 255 inclusive
    abstract byte: ?context: {| messageTemplate: string option |} -> Validator
    abstract date: unit -> Validator
    /// Returns a ISO 8601 duration string Validator.
    abstract duration: unit -> Validator
    /// Validators number, double, and single are all the same
    abstract number: ?context: {| messageTemplate: string option |} -> Validator
    /// Validators number, double, and single are all the same
    abstract double: ?context: {| messageTemplate: string option |} -> Validator
    /// Validators number, double, and single are all the same
    abstract single: ?context: {| messageTemplate: string option |} -> Validator
    abstract guid: unit -> Validator
    abstract int16: ?context: {| messageTemplate: string option |} -> Validator
    abstract int32: ?context: {| messageTemplate: string option |} -> Validator
    abstract int64: ?context: {| messageTemplate: string option |} -> Validator
    /// Same as int64
    abstract integer: ?context: {| messageTemplate: string option |} -> Validator
    abstract maxLength: context: {| maxLength: float; messageTemplate: string option |} -> Validator
    abstract required: ?context: {| messageTemplate: string option |} -> Validator
    abstract string: unit -> Validator
    abstract stringLength: context: {| maxLength: float; minLength: float; messageTemplate: string option |} -> Validator
    /// Returns a credit card number validator that performs a Luhn algorithm checksum test for plausability
    abstract creditCard: ?context: {| messageTemplate: string option |} -> Validator
    /// Returns a regular expression validator; the expression must be specified in the context parameter
    abstract regularExpression: context: {| expression: RegExp; messageTemplate: string option |} -> Validator
    /// Returns the email address validator
    abstract emailAddress: ?context: {| messageTemplate: string option |} -> Validator
    /// Returns the phone validator, which handles prefix, country code, area code, and local number, with [-/. ] break characters.
    abstract phone: ?context: {| messageTemplate: string option |} -> Validator
    /// Returns the URL (protocol required) validator
    abstract url: ?context: {| messageTemplate: string option |} -> Validator
    /// Always returns true
    abstract none: unit -> Validator
    /// Creates a validator instance from a JSON object or an array of instances from an array of JSON objects.
    abstract fromJSON: json: string -> Validator
    /// Register a validator instance so that any deserialized metadata can reference it.
    abstract register: validator: Validator -> unit
    /// Register a validator factory so that any deserialized metadata can reference it.
    abstract registerFactory: fn: ((obj) option -> Validator) * name: string -> unit
    /// Creates a regular expression validator with a fixed expression.
    abstract makeRegExpValidator: validatorName: string * expression: RegExp * defaultMessage: string * ?context: obj -> Validator

type [<AllowNullLiteral>] ValidatorFunction =
    [<Emit("$0($1...)")>] abstract Invoke: value: obj option * context: ValidatorFunctionContext -> unit

type [<AllowNullLiteral>] ValidatorFunctionContext =
    abstract value: obj option with get, set
    abstract validatorName: string with get, set
    abstract displayName: string with get, set
    abstract messageTemplate: string with get, set
    abstract message: string option with get, set

module Config =

    type [<AllowNullLiteral>] IExports =
        abstract ajax: string with get, set
        abstract dataService: string with get, set
        abstract functionRegistry: Object with get, set
        /// <summary>Returns the ctor function used to implement a specific interface with a specific adapter name.</summary>
        /// <param name="interfaceName">One of the following interface names "ajax", "dataService" or "modelLibrary"</param>
        /// <param name="adapterName">
        /// The name of any previously registered adapter. If this parameter is omitted then
        /// this method returns the "default" adapter for this interface. If there is no default adapter, then a null is returned.
        /// </param>
        /// <returns>Returns either a ctor function or null.</returns>
        abstract getAdapter: interfaceName: string * ?adapterName: string -> Function
        /// <summary>Returns the adapter instance corresponding to the specified interface and adapter names.</summary>
        /// <param name="interfaceName">The name of the interface.</param>
        /// <param name="adapterName">
        /// The name of a previously registered adapter.  If this parameter is
        /// omitted then the default implementation of the specified interface is returned. If there is
        /// no defaultInstance of this interface, then the first registered instance of this interface is returned.
        /// </param>
        /// <returns>instance of the specified adapter}</returns>
        abstract getAdapterInstance: interfaceName: string * ?adapterName: string -> Object
        /// <summary>
        /// Initializes a single adapter implementation. Initialization means either newing a instance of the
        /// specified interface and then calling "initialize" on it or simply calling "initialize" on the instance
        /// if it already exists.
        /// </summary>
        /// <param name="interfaceName">The name of the interface to which the adapter to initialize belongs.</param>
        /// <param name="adapterName">The name of a previously registered adapter to initialize.</param>
        /// <param name="isDefault">=true {Boolean} - Whether to make this the default "adapter" for this interface.</param>
        /// <returns>instance of the specified adapter}</returns>
        abstract initializeAdapterInstance: interfaceName: string * adapterName: string * ?isDefault: bool -> Object
        /// <summary>Initializes a collection of adapter implementations and makes each one the default for its corresponding interface.</summary>
        /// <param name="config" />
        /// <returns>[array of instances]</returns>
        abstract initializeAdapterInstances: config: AdapterInstancesConfig -> ResizeArray<Object>
        abstract interfaceInitialized: Event with get, set
        abstract interfaceRegistry: Object with get, set
        abstract objectRegistry: Object with get, set
        /// <summary>
        /// Method use to register implementations of standard breeze interfaces.  Calls to this method are usually
        /// made as the last step within an adapter implementation.
        /// </summary>
        /// <param name="interfaceName">one of the following interface names "ajax", "dataService" or "modelLibrary"</param>
        /// <param name="adapterCtor">an ctor function that returns an instance of the specified interface.</param>
        abstract registerAdapter: interfaceName: string * adapterCtor: Function -> unit
        abstract registerFunction: fn: Function * fnName: string -> unit
        abstract registerType: ctor: Function * typeName: string -> unit
        /// <summary>Set the promise implementation, if Q.js is not found.</summary>
        /// <param name="q">implementation of promise.</param>
        /// <seealso href="http://wiki.commonjs.org/wiki/Promises/A" />
        abstract setQ: q: Promises.IPromiseService -> unit
        abstract stringifyPad: string with get, set
        abstract typeRegistry: Object with get, set

    type [<AllowNullLiteral>] AdapterInstancesConfig =
        /// the name of a previously registered "ajax" adapter
        abstract ajax: string option with get, set
        /// the name of a previously registered "dataService" adapter
        abstract dataService: string option with get, set
        /// the name of a previously registered "modelLibrary" adapter
        abstract modelLibary: string option with get, set
        /// the name of a previously registered "uriBuilder" adapter
        abstract uriBuilder: string option with get, set

/// <summary>Promises interface used by Breeze.  Usually implemented by Q (<see href="https://github.com/kriskowal/q)" /> or angular.$q using config.setQ(impl)</summary>
module Promises =

    type [<AllowNullLiteral>] IDeferred<'T> =
        abstract promise: Promise<'T> with get, set
        abstract resolve: value: 'T -> unit
        abstract reject: reason: obj option -> unit

    type [<AllowNullLiteral>] IPromiseService =
        abstract defer: unit -> IDeferred<'T>
        abstract reject: ?reason: obj -> Promise<obj option>
        abstract resolve: object: 'T -> Promise<'T>
        abstract resolve: object: Promise<'T> -> Promise<'T>

type [<AllowNullLiteral>] JsonResultsAdapterExtractResults =
    interface end

type [<AllowNullLiteral>] EntityManagerImportEntitiesTempKeyMapping =
    [<EmitIndexer>] abstract Item: key: string -> EntityKey with get, set
